<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
  <title>Document</title>
  <style>
    table,
    th,
    td {
      padding: 0rem .5rem;
      border: 1px solid black;
      border-collapse: collapse;
    }

    .table-no-border {
      border: 0px solid black;
      border-collapse: separate;
    }

    .no-border {
      border: 0px solid black;
    }

    th {
      background-color: lightgray;
      text-align: center;
    }

    .prefer {
      color: blue;
    }

    .warning {
      color: red;
    }

    .chapter {
      background-color: black;
      color: white;
      padding: 5px
    }

    .chapter-title {
      background-color: black;
      color: orange;
      padding: 5px
    }

    .chapter-number {
      background-color: orange;
      color: black;
      padding: 5px;
      margin-right: 5px;
    }

    h4 {
      margin-bottom: 0;
    }

    ul {
      margin: .25rem 0rem;
    }

    li {
      line-height: 1.3rem;
    }

    code {
      font-weight: bold;
      background-color: lightgray;
      padding: .25rem;
      border-radius: .5rem;
    }

    pre {
      margin: .25rem;
      border-radius: .5rem;
      padding: .25rem .5rem;
      font-size: .9rem;
      background-color: #242;
      color: whitesmoke;
      width: fit-content;
    }

    .no-bg {
      background-color: transparent;
      color: black;
    }

    .float {
      position: fixed;
      width: 60px;
      height: 60px;
      bottom: 30px;
      right: 30px;
      background-color: royalblue;
      color: #FFF;
      border-radius: 30px;
      text-align: center;
    }

    .my-float {
      margin-top: 5px;
      font-size: 3rem;
    }

    .my-strong {
      background-color: black;
      color: orange;
      border-radius: .5rem;
      padding: .1rem .5rem;
    }

    caption {
      margin-top: .25rem;
    }

    img {
      max-width: 100%;
      height: auto
    }
  </style>
</head>

<body>
  <a href="#end" class="float">
    <span class="material-icons my-float">
      arrow_circle_down
    </span>
  </a>
  <h1 class="chapter-title"><span class="chapter-number">01</span>Android Studio와 친숙해지기</h1>
  <h2>01-3 레이아웃 기초 익히기</h2>
  <table>
    <tr>
      <th>접두어</th>
      <th>의미</th>
    </tr>
    <tr>
      <td>xmlns:android</td>
      <td>Android 기본 SDK에 포함되어 있는 속성</td>
    </tr>
    <tr>
      <td>xmlns:app</td>
      <td>외부 library에 포함되어 있는 속성</td>
    </tr>
    <tr>
      <td>xmlns:tools</td>
      <td>Android Studio에서만 사용되는 속성</td>
    </tr>
  </table>
  <p></p>
  <table>
    <caption>크기를 표시하는 단위와 Margin</caption>
    <tr>
      <th>단위</th>
      <th>표현</th>
      <th>설명</th>
    </tr>
    <tr>
      <td>px</td>
      <td>pixel</td>
      <td></td>
    </tr>
    <tr>
      <td class="prefer">dp</td>
      <td>density independent pixel</td>
      <td>160dpi 화면을 기준으로 한 pixel<br>
        ex) 160px/inch 에서는 1dp = 1px, 320px/inch 에서는 1dp = 2px</td>
    </tr>
    <tr>
      <td class="prefer">sp</td>
      <td>scale independent pixel</td>
      <td>text 크기를 지정할 때 사용.<br>
        가변 글꼴을 기준으로 한 pixel. 글꼴의 설정에 따라 1sp 당 pixel 수가 달라진다.</td>
    </tr>
    <tr>
      <td>in</td>
      <td>inch</td>
      <td></td>
    </tr>
    <tr>
      <td>mm</td>
      <td>Millimeter</td>
      <td></td>
    </tr>
    <tr>
      <td>em</td>
      <td>text 크기</td>
      <td>글꼴과 상관없이 동일한 크기를 표시한다.</td>
    </tr>
  </table>
  * view에는 dp, 글자는 sp를 사용한다.<br>
  <p class="warning">주의) "app/src/main/res" folder에 file을 추가할 때 file 이름은 영어 소문자, 숫자, _ 기호로만 만들어야 하며, 첫 글자는 영문자로 시작해야 한다.</p>
  <h1 class="chapter-title"><span class="chapter-number">02</span>Layout 익히기</h1>
  <h2>02-1 대표적인 Layout</h2>
  <table>
    <caption style="text-align: left;">Android에서 제공하는 대표적인 Layout</caption>
    <tr>
      <th>Layout</th>
      <th>설명</th>
    </tr>
    <tr>
      <td>ConstraintLayout</td>
      <td>기본 설정</td>
    </tr>
    <tr>
      <td>LinearLayout</td>
      <td>한 쪽 방향으로 차례대로 view를 추가하며 화면을 구성</td>
    </tr>
    <tr>
      <td>FrameLayout</td>
      <td>가장 상위에 있는 하나의 view 또는 view-group만 보여주는 방법</td>
    </tr>
    <tr>
      <td>TableLayout</td>
      <td>격자 모양의 배열을 사용하여 화면을 구성</td>
    </tr>
  </table>
  <h4>View 영역 알아보기</h3>
    <ul>
      <li>view 영역(Box)</li>
      <li>view 테두리(Border)</li>
      <li>Margin</li>
      <li>Padding</li>
    </ul>
    <h4>View의 색상</h3>
      <table>
        <tr>
          <th>속성</th>
          <th>값 형식</th>
        </tr>
        <tr>
          <td>background</td>
          <td>#[A]RGB, #[AA]RRGGBB 16진수로 표현한다.</td>
        </tr>
      </table>
      <h2>02-2 LinearLayout</h2>
      <h4>방향 설정</h4>
      orientation = vertical | horizontal
      <h4>코드에서 화면 구성하기</h4>
      <pre>
package com.xxx.hello

import android.os.Bundle
import android.widget.Button
import android.widget.LinearLayout
import androidx.appcompat.app.AppCompatActivity

class MainActivity2 : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        val main = LinearLayout(this)
        main.orientation = LinearLayout.VERTICAL

        val button = Button(this)
        button.text = "Button1"
        button.layoutParams = LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT,
            LinearLayout.LayoutParams.WRAP_CONTENT)

        main.addView(button)

        setContentView(main)
    }
}</pre>
      <h4>화면 생성 과정 분석하기</h4>
      context - UI 구성 요소인 view에 대한 정보를 담고 있는 객체.
      <h4>view 정렬하기</h4>
      <table>
        <caption>두 가지 정렬 속성</caption>
        <tr>
          <th>속성</th>
          <th>설명</th>
          <th>값</th>
        </tr>
        <tr>
          <td>layout_gravity</td>
          <td>부모 container의 여유 공간 안에 view들을 정렬한다.</td>
          <td>left, center, right, top, bottom 등</td>
        </tr>
        <tr>
          <td>gravity</td>
          <td>view 안에 표시하는 내용물을 정렬한다.<br>ex) TextView 안의 text</td>
          <td>left, center, right, top, bottom 등<br> | 연산자를 사용해 여러 개의 값을 설정할 수 있다. 이때 | 연산자 양쪽에 공백이 없어야 한다.</td>
        </tr>
      </table>
      <p>view의 글자 높이를 맞추는 LinearLayout의 <b>baselineAligned</b> 속성의 기본값은 true 이다.</p>
      <h4>view의 margin과 padding 설정하기</h4>
      <h4>여유 공간을 분할하는 layout_weight 속성</h4>
      <ul>
        <li>부모 container의 여유 공간을 분할하여 각 view들에게 할당한다.</li>
        <li>layout_width, layout_height는 <b>wrap_content</b>나 <b>숫자값</b>으로 지정해야 한다.</li>
        <li>설정 값은 비율이다.<br>ex) 두 개의 view에 각 1, 2를 설정하면 각 1/3, 2/3의 여유 공간을 할당 받는다.</li>
      </ul>
      <h2>02-3 RelativeLayout</h2>
      <ul>
        <li>Constraint layout으로 대체되었다.</li>
        <li>부모 container나 다른 view와의 상대적인 위치를 이용해 위치를 결정한다.</li>
      </ul>
      <table>
        <caption>부모 container와의 상대적인 위치</caption>
        <tr>
          <th>속성</th>
          <th>설명</th>
        </tr>
        <tr>
          <td>layout_alignParentTop</td>
          <td>부모 container의 위쪽과 view의 위쪽을 맞춘다.</td>
        </tr>
        <tr>
          <td>layout_alignParentBottom</td>
          <td>부모 container의 아래쪽과 view의 아래쪽을 맞춘다.</td>
        </tr>
        <tr>
          <td>layout_alignParentLeft</td>
          <td>부모 container의 왼쪽과 view의 왼쪽을 맞춘다.</td>
        </tr>
        <tr>
          <td>layout_alignParentRight</td>
          <td>부모 container의 오른쪽과 view의 오른쪽을 맞춘다.</td>
        </tr>
        <tr>
          <td>layout_centerHorizontal</td>
          <td>부모 container의 수평 방향 중앙에 배치한다.</td>
        </tr>
        <tr>
          <td>layout_centerVertical</td>
          <td>부모 container의 수직 방향 중앙에 배치한다.</td>
        </tr>
        <tr>
          <td>layout_centerInParent</td>
          <td>부모 container의 수평, 수직 방향 중앙에 배치한다.</td>
        </tr>
      </table>
      <p></p>
      <table>
        <caption>다른 view와의 상대적인 위치</caption>
        <tr>
          <th>속성</th>
          <th>설명</th>
        </tr>
        <tr>
          <td>layout_above</td>
          <td>지정한 view의 위쪽에 배치한다.</td>
        </tr>
        <tr>
          <td>layout_below</td>
          <td>지정한 view의 아래쪽에 배치한다.</td>
        </tr>
        <tr>
          <td>layout_toLeftOf</td>
          <td>지정한 view의 왼쪽에 배치한다.</td>
        </tr>
        <tr>
          <td>layout_toRightOf</td>
          <td>지정한 view의 오른쪽에 배치한다.</td>
        </tr>
        <tr>
          <td>layout_alignTop</td>
          <td>지정한 view의 위쪽과 맞춘다.</td>
        </tr>
        <tr>
          <td>layout_alignBottom</td>
          <td>지정한 view의 아래쪽과 맞춘다.</td>
        </tr>
        <tr>
          <td>layout_alignLeft</td>
          <td>지정한 view의 왼쪽과 맞춘다.</td>
        </tr>
        <tr>
          <td>layout_alignRight</td>
          <td>지정한 view의 오른쪽과 맞춘다.</td>
        </tr>
        <tr>
          <td>layout_alignBaseline</td>
          <td>지정한 view와 내용물의 아래쪽 기준선을 맞춘다.</td>
        </tr>
      </table>
      <h2>02-4 TableLayout</h2>
      <ul>
        <li>TableRow : 행</li>
        <li>View : 열</li>
        <li>TableRow의 높이 값은 내부적으로 항상 wrap_content로 설정되어 있어 화면을 꽉 채울 수 없다.</li>
        <li>너비 값은 항상 match_parent 설정되어 가로 공간을 꽉 채운다.</li>
        <li>stretchColumns로 행의 여유공간까지 모두 채울 수 있다.<br>
          값은 column index를 지정한다. ex) android:stretchColumns="0,1,2"
        </li>
        <li>TableRow tag 안에 추가하는 view는 순서대로 0부터 시작하는 column index를 자동으로 부여 받는다.<br>
          하지만 layout_column 속성으로 column index를 지정하면 그 순서를 설정 할 수 있다.</li>
        <li>layout_span은 view가 여러 column에 걸쳐 있도록 만들기 위한 속성이다.</li>
      </ul>
      <h2>02-5 FrameLayout과 view의 전환</h2>
      <ul>
        <li>FrameLayout에 view를 넣으면 그중에서 하나의 view만 화면에 표시한다.</li>
        <li>view를 추가할 때마다 하나씩 위쪽에 쌓이고(overlay) 제일 위에 있는 view만 화면에 보여진다.</li>
        <li>visibility 속성을 <b>visible | invisible | gone</b> 중 하나로 설정해서 view의 표시 여부를 지정할 수 있다.</li>
        <li></li>
      </ul>
      Resource id 참조 방법
      <ul>
        <li>XML : @+id/resource_id</li>
        <li>source code : R.id.resource_id</li>
      </ul>
      source 에서 view을 찾는 방법
      <ul>
        <li>findViewById</li>
        <li>view binding
          <pre>
// build.gradle(Module)
android {
...          
  // 추가
  buildFeatures {
      viewBinding true
  }
...
}</pre>
        </li>
      </ul>
      <h2>02-6 ScrollView</h2>
      <ul>
        <li>ScrollView : default. vertical.</li>
        <li>HorizontalScrollView</li>
      </ul>
      <h1 class="chapter-title"><span class="chapter-number">03</span>기본 Widget과 Drawable 사용하기</h1>
      <h2>03-1 기본 Widget 다시 한 번 자세히 공부하기</h2>
      <h4>TextView</h4>
      <table>
        <tr>
          <th>속성</th>
          <th>설명</th>
          <th>값</th>
        </tr>
        <tr>
          <td>text</td>
          <td>문자열</td>
          <td>직접 문자열을 넣거나 /app/res/values/strings.xml에 작성한 문자열을 지정한다.<br>
            <pre>
  &lt;!-- strings.xml -->
  &lt;resources>
    &lt;string name="person_name">홍길동&lt;/string>
  &lt;/resources></pre>
            ex) android:text="@string/person_name"
          </td>
        </tr>
        <tr>
          <td colspan="3">다국어 지원하기<br>
            <ul>
              <li>/app/res/values-en/strings.xml 영어 지원</li>
              <li>/app/res/values-ko/strings.xml 한글 지원</li>
            </ul>
            strings.xml이 저장될 folder 이름은 반드시 'values-{locale 이름}'으로 해야한다.<br>
            단말기의 언어 설정에 따라 일치하는 strings.xml을 사용한다.<br>
            일치하는 언어가 없다면 기본 folder인 values/strings.xml이 사용된다.
          </td>
        </tr>
        <tr>
          <td>textColor</td>
          <td>문자열의 색상</td>
          <td>#AARRGGBB</td>
        </tr>
        <tr>
          <td>textSize</td>
          <td>문자열의 크기(폰트 크기)</td>
          <td>'sp' 단위를 권장한다.</td>
        </tr>
        <tr>
          <td>textStyle</td>
          <td>문자열의 style</td>
          <td>normal, bold, italic<br>
            '|' 기호를 사용해 여러 개의 속성을 함께 지정할 수 있다. 이때 '|' 기호의 앞뒤에 공백이 없어야 한다.</td>
        </tr>
        <tr>
          <td>typeFace</td>
          <td>글꼴</td>
          <td>normal, sans, serif, monospace</td>
        </tr>
        <tr>
          <td>maxLines</td>
          <td>최대 줄 수</td>
          <td></td>
        </tr>
      </table>
      <h4>Button</h4>
      <ul>
        <li>Button은 TextView를 상속 받는다.</li>
        <li>CompoundButton</li>
        <li>CheckBox</li>
        <li>RadioButton</li>
      </ul>
      <table>
        <tr>
          <th>속성</th>
          <th>설명</th>
          <th>값</th>
        </tr>
        <tr>
          <td>checked</td>
          <td>checkBox와 radioButton의 선택 여부 설정</td>
          <td>true | false</td>
        </tr>
      </table>
      <h4>EditText</h4>
      <table>
        <tr>
          <th>속성</th>
          <th>설명</th>
          <th>값</th>
        </tr>
        <tr>
          <td>inputType</td>
          <td>입력 값 유형을 지정한다.</td>
          <td>text | number | date | phone 등.</td>
        </tr>
        <tr>
          <td>hint</td>
          <td>입력 항목의 안내글. 글자를 입력하면 사라진다.</td>
          <td></td>
        </tr>
        <tr>
          <td>textColorHint</td>
          <td>안내글 색상을 지정한다.</td>
          <td></td>
        </tr>
      </table>
      <h4>ImageView, ImageButton</h4>
      <ul>
        <li>image를 화면에 표시할 때 사용한다.</li>
        <li>표시하려는 image는 /app/res/drawable folder에 저장한다.</li>
      </ul>
      <table>
        <tr>
          <th>속성</th>
          <th>설명</th>
          <th>값</th>
        </tr>
        <tr>
          <td>android:src 또는 app:srcCompat</td>
          <td>image file 이름을 확장자는 제외하고 지정한다.<br>app:srcCompat="@drawable/{image file name}"</td>
          <td>png(권장) 또는 jpg</td>
        </tr>
        <tr>
          <td>maxWidth, maxHeight</td>
          <td>image 원본이 너무 크면 이 속성으로 최대 크기를 제한할 수 있다.</td>
          <td></td>
        </tr>
        <tr>
          <td>tint</td>
          <td>image의 색상을 설정한다.</td>
          <td>"#AARRGGBB"</td>
        </tr>
        <tr>
          <td>scaleType</td>
          <td>imageView의 크기에 맞게 원본 이미지의 크기를 자동으로 늘리거나 줄여서 보여줄 때 사용한다.</td>
          <td>fitXY | centgerCrop | centerInside 등</td>
        </tr>
      </table><br>
      <table>
        <tr>
          <th>해상도</th>
          <th>folder 이름</th>
        </tr>
        <tr>
          <td>초고해상도</td>
          <td>/app/res/[drawable-xhdpi|drawable-xxhdpi|drawable-xxxhdpi]</td>
        </tr>
        <tr>
          <td>고해상도</td>
          <td>/app/res/drawable-hdpi</td>
        </tr>
        <tr>
          <td>중간 해상도</td>
          <td>/app/res/drawable-mdpi</td>
        </tr>
        <tr>
          <td>저해상도</td>
          <td>/app/res/drawable-ldpi</td>
        </tr>
      </table>
      <h4>TextView, EditText의 다른 기능들</h4>
      <table>
        <tr>
          <th>속성</th>
          <th>설명</th>
          <th>값</th>
        </tr>
        <tr>
          <td>selectAllOnFocus</td>
          <td>true 면 focus를 받을 때 전체 문자열을 선택한다.</td>
          <td>true | false</td>
        </tr>
        <tr>
          <td>autoLink</td>
          <td>문서에 표함된 web page 주소나 email 주소를 link 색상으로 표시하고<br>누르면 바로 접속하거나 mail 편집기를 띄워주는 기능을 간단하게 넣을 수 있다.</td>
          <td>true | false</td>
        </tr>
        <tr>
          <td>lineSpacingMultiplier<br>lineSpacingExtra</td>
          <td>줄 간격 조정</td>
          <td></td>
        </tr>
        <tr>
          <td>capitalize</td>
          <td>글자, 단어, 문장 단위로 대소문자를 조절할 수 있다</td>
          <td>characters | words | sentences</td>
        </tr>
        <tr>
          <td>ellipsize</td>
          <td>긴 문자열을 생략하여 ... 으로 표시한다.</td>
          <td>none | start | middle | end</td>
        </tr>
        <tr>
          <td>editable</td>
          <td>입력되어 있는 문자열을 편집하지 못하게 하고 싶다면 false를 지정한다.</td>
          <td>true | false</td>
        </tr>
      </table>
      <h2>03-2 Drawable 만들기</h2>
      <h4>Drawable</h4>
      View에 설정할 수 있는 객체. XML file.
      <table>
        <caption>종류</caption>
        <tr>
          <th>drawable</th>
          <th>설명</th>
        </tr>
        <tr>
          <td>BitmapDrawable</td>
          <td>image file을 보여줄 때 사용한다. bitmap graphic file(png, jpg, gif 등)</td>
        </tr>
        <tr>
          <td>StateListDrawable</td>
          <td>상태별로 다른 bitmap graphic을 참조한다.</td>
        </tr>
        <tr>
          <td>TransitionDrawable</td>
          <td>두 개의 drawable을 서로 전환할 수 있다.</td>
        </tr>
        <tr>
          <td>ShapeDrawable</td>
          <td>색상과 gradation을 포함하여 도형 모양을 정의할 수 있다.</td>
        </tr>
        <tr>
          <td>InsetDrawable</td>
          <td>지정된 거리만큼 다른 drawable을 들어서 보여줄 수 있다.</td>
        </tr>
        <tr>
          <td>ClipDrawable</td>
          <td>level 값을 기준으로 다른 drawable을 clipping할 수 있다.</td>
        </tr>
        <tr>
          <td>ScaleDrawable</td>
          <td>level 값을 기준으로 다른 drawable 크기를 변경할 수 있다.</td>
        </tr>
      </table>
      <h4>StateListDrawable 만들기</h4>
      View의 상태에 따라 view에 보여줄 graphic을 다르게 지정할 수 있다.<br><br>
      app/res/drawable/finger_drawable.xml
      <pre>
&lt;?xml version="1.0" encoding="utf-8"?>
&lt;selector xmlns:android="http://schemas.android.com/apk/res/android">
  &lt;item android:drawable="@drawable/finger_pressed" 
        android:state_pressed="true" />
  &lt;item android:drawable="@drawable/finger" />
&lt;/selector></pre>
      이렇게 만든 xml을 view의 background로 지정한다.
      <h4>ShapeDrawable 만들기</h4>
      /app/res/rect_drawable.xml 사각형
      <pre>
&lt;?xml version="1.0" encoding="utf-8"?>
&lt;shape
  xmlns:android="http://schemas.android.com/apk/res/android"
  android:shape="rectangle">
  &lt;size
    android:width="200dp"
    android:height="120dp" />
  &lt;stroke
    android:width="4dp"
    android:color="#070" />
  &lt;solid android:color="#f77" />
  &lt;padding android:bottom="1dp" />
&lt;/shape></pre><br>
      /app/res/back_drawable.xml
      <pre>
&lt;?xml version="1.0" encoding="utf-8"?>
&lt;shape
xmlns:android="http://schemas.android.com/apk/res/android">
  &lt;gradient
    android:angle="90"
    android:centerColor="#3250b4"
    android:centerY="0.5"
    android:endColor="#254095"
    android:startColor="#7288db" />
  &lt;corners android:radius="2dp" />
&lt;/shape>
</pre><br>
      &lt;layer-list> tag를 사용하면 여러 개의 graphic를 하나의 xml file에 넣을 수 있다.
      <pre>
&lt;?xml version="1.0" encoding="utf-8"?>
&lt;layer-list
  xmlns:android="http://schemas.android.com/apk/res/android">

  &lt;item>
    &lt;shape android:shape="rectangle">
      &lt;stroke
          android:width="1dp"
          android:color="#0F0" />
      &lt;solid android:color="#00000000" />
      &lt;size
        android:width="200dp"
        android:height="100dp" />
    &lt;/shape>
  &lt;/item>

  &lt;item android:top="1dp" android:bottom="1dp" android:right="1dp" android:left="1dp">
    &lt;shape android:shape="rectangle">
      &lt;stroke android:width="1dp" android:color="#F00"/>
      &lt;solid android:color="#00000000" />
    &lt;/shape>
  &lt;/item>
&lt;/layer-list></pre>
      <h2>03-3 Event 처리 이해하기</h2>
      <h4>event 처리 방식</h4>
      <ul>
        <li>MotionEvent</li>
        <li>KeyEvent</li>
      </ul>
      <table>
        <caption>대표적인 event 유형</caption>
        <tr>
          <th>속성</th>
          <th>설명</th>
          <th>Listener</th>
        </tr>
        <tr>
          <td>Click</td>
          <td>view를 click할 때 발생한다.</td>
          <td>android.view.View.OnClickListener<br>abstract fun onClick(v: View!): Unit</td>
        </tr>
        <tr>
          <td>Touch</td>
          <td>화면을 손가락으로 누를 때 발생한다.</td>
          <td>android.view.View.OnTouchListener<br>abstract fun onTouch(v: View!, event: MotionEvent!):Boolean</td>
        </tr>
        <tr>
          <td>Key</td>
          <td>keypad나 hardware button을 누를 때 발생한다.</td>
          <td>android.view.View.OnKeyListener<br>abstract fun onKey(v: View!, keyCode: Int, event: KeyEvent!)</td>
        </tr>
        <tr>
          <td>Gesture</td>
          <td>touch event 중에서 scroll과 같이 일정한 pattern으로 구분되는 event</td>
          <td></td>
        </tr>
        <tr>
          <td>Focus</td>
          <td>view마다 순서대로 주어지는 focus</td>
          <td>android.view.View.OnFocusChangeListener<br>abstract fun onFocusChange(v: View!, hasFocus: Boolean): Unit</td>
        </tr>
        <tr>
          <td>회전 방향 변경</td>
          <td>화면의 방향이 가로와 세로로 바뀔 때 발생한다.</td>
          <td></td>
        </tr>
      </table><br>
      <table>
        <caption>Gesture event를 통해 처리할 수 있는 event 유형들</caption>
        <tr>
          <th>method</th>
          <th>event 유형</th>
        </tr>
        <tr>
          <td>onDown()</td>
          <td>화면이 눌렸을 경우</td>
        </tr>
        <tr>
          <td>onShowPress()</td>
          <td>화면이 눌렸다 떼어지는 경우</td>
        </tr>
        <tr>
          <td>onSingleTapUp()</td>
          <td>화면이 한 손가락으로 눌렸다 떼어지는 경우</td>
        </tr>
        <tr>
          <td>onSingleTapConfirmed()</td>
          <td>화면이 한 손가락으로 눌려지는 경우</td>
        </tr>
        <tr>
          <td>onDoubleTap()</td>
          <td>화면이 두 손가락으로 눌려지는 경우</td>
        </tr>
        <tr>
          <td>onDoubleTapEvent()</td>
          <td>화면이 두 손가락으로 눌려진 상태에서 떼거나 이동하는 등 세부적인 액션을 취하는 경우</td>
        </tr>
        <tr>
          <td>onScroll()</td>
          <td>화면이 눌린 채 일정한 속도와 방향으로 움직였다 떼는 경우</td>
        </tr>
        <tr>
          <td>onFling()</td>
          <td>화면이 눌린 채 가속도를 붙여 손가락을 움직였다 떼는 경우</td>
        </tr>
        <tr>
          <td>onLongPress()</td>
          <td>화면을 손가락으로 오래 누르는 경우</td>
        </tr>
      </table>
      <h4>Touch event 처리하기</h4>
      activity_main.xml
      <pre>
&lt;?xml version="1.0" encoding="utf-8"?>
&lt;LinearLayout
  xmlns:android="http://schemas.android.com/apk/res/android"
  xmlns:app="http://schemas.android.com/apk/res-auto"
  xmlns:tools="http://schemas.android.com/tools"
  android:layout_width="match_parent"
  android:layout_height="match_parent"
  android:orientation="vertical"
  tools:context=".MainActivity">

  &lt;View
    android:id="@+id/view"
    android:layout_width="match_parent"
    android:layout_height="0dp"
    android:layout_weight="1"
    android:background="#faa" />

  &lt;View
    android:id="@+id/view2"
    android:layout_width="match_parent"
    android:layout_height="0dp"
    android:layout_weight="1"
    android:background="#afa" />

  &lt;ScrollView
    android:layout_width="match_parent"
    android:layout_height="0dp"
    android:layout_weight="1"
    android:background="#aaf">

    &lt;LinearLayout
      android:layout_width="match_parent"
      android:layout_height="wrap_content"
      android:orientation="vertical">

      &lt;TextView
        android:id="@+id/textView"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:textColor="@color/black"
        android:textSize="16sp" />
    &lt;/LinearLayout>
  &lt;/ScrollView>
&lt;/LinearLayout></pre><br>
      MainActivity.kt
      <pre>
package com.xxx.sampleevent

import android.os.Bundle
import android.view.MotionEvent
import androidx.appcompat.app.AppCompatActivity
import com.jeongchaeuk.sampleevent.databinding.ActivityMainBinding

class MainActivity : AppCompatActivity() {
    private lateinit var binding: ActivityMainBinding

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        binding = ActivityMainBinding.inflate(layoutInflater)
        setContentView(binding.root)

        binding.view.setOnTouchListener { _, event ->
            when (event.action) {
                MotionEvent.ACTION_DOWN -> {
                    print("action_down [${event.x} ${event.y}]")
                }
                MotionEvent.ACTION_MOVE -> {
                    print("action_move [${event.x} ${event.y}]")
                }
                MotionEvent.ACTION_UP -> {
                    print("action_up [${event.x} ${event.y}]")
                }
                else -> {
                    print("nothing")
                }
            }

            true
        }
    }

    fun print(text: String) {
        binding.textView.append(text+"\n")
    }
}</pre>
      <h4>Gesture event 처리하기</h4>
      참고: <a href="https://developer.android.com/training/gestures" target="_blank">Use touch gestures</a>
      <pre>
package com.xxx.sampleevent

import android.os.Bundle
import android.view.GestureDetector
import android.view.MotionEvent
import androidx.appcompat.app.AppCompatActivity
import com.jeongchaeuk.sampleevent.databinding.ActivityMainBinding

class MainActivity : AppCompatActivity(), GestureDetector.OnGestureListener {
    private lateinit var binding: ActivityMainBinding
    private lateinit var detector: GestureDetector

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        binding = ActivityMainBinding.inflate(layoutInflater)
        this.setContentView(binding.root)

        detector = GestureDetector(this, this)

        binding.view.setOnTouchListener { v, event ->
            when (event.action) {
                MotionEvent.ACTION_DOWN -> {
                    print("action_down [${event.x} ${event.y}]")
                }
                MotionEvent.ACTION_MOVE -> {
                    print("action_move [${event.x} ${event.y}]")
                }
                MotionEvent.ACTION_UP -> {
                    print("action_up [${event.x} ${event.y}]")
                }
                else -> {
                    print("nothing")
                }
            }

            v.performClick()
            true
        }

        binding.view2.setOnTouchListener { v, event ->
            detector.onTouchEvent(event)
            v.performClick()
            true
        }
    }

    private fun print(text: String) {
        binding.textView.append(text+"\n")
    }

    override fun onDown(e: MotionEvent?): Boolean {
        print("called onDown()")
        return true
    }

    override fun onShowPress(e: MotionEvent?) {
        print("called onShowPress()")
    }

    override fun onSingleTapUp(e: MotionEvent?): Boolean {
        print("called onShowPress()")
        return true
    }

    override fun onScroll(
        e1: MotionEvent?,
        e2: MotionEvent?,
        distanceX: Float,
        distanceY: Float,
    ): Boolean {
        print("called onScroll(), x=$distanceX, y=$distanceY")
        return true
    }

    override fun onLongPress(e: MotionEvent?) {
        print("called onLongPress()")
    }

    override fun onFling(
        e1: MotionEvent?,
        e2: MotionEvent?,
        velocityX: Float,
        velocityY: Float,
    ): Boolean {
        print("called onFling(), x=$velocityX, y=$velocityY")
        return true
    }
}</pre>
      <h4>Key event 처리하기</h4>
      <ul>
        <li>abstract fun onKeyDown(keyCode: Int, event: KeyEvent!): Boolean</li>
        <li>interface OnKeyListener<br>abstract fun onKey(v: View!, keyCode: Int, event: KeyEvent!): Boolean</li>
      </ul>
      <table>
        <caption></caption>
        <tr>
          <th>key code</th>
          <th>설명</th>
        </tr>
        <tr>
          <td>KEYCODE_DPAD_[LEFT | RIGHT | UP | DOWN | CENTER]</td>
          <td>방향 화살표, 중앙</td>
        </tr>
        <tr>
          <td>KEYCODE_[CALL | ENDCALL]</td>
          <td>통화, 통화 종료</td>
        </tr>
        <tr>
          <td>KEYCODE_BACK</td>
          <td>뒤로가기</td>
        </tr>
        <tr>
          <td>KEYCODE_CAMERA</td>
          <td>camera</td>
        </tr>
        <tr>
          <td>KEYCODE_VOLUME_[UP | DOWN]</td>
          <td>소리 쿠기 증가, 감소</td>
        </tr>
        <tr>
          <td>KEYCODE_[0-9 | A-Z]</td>
          <td>0~9, A~Z</td>
        </tr>
      </table>
      <h4>단말 방향(Orientation)을 전환했을 때 event 처리하기</h4>
      <ul>
        <li>activity는 memory에서 없어졌다가 다시 만들어 진다.</li>
        <li>방향을 바꿨을 떄 다른 XML layout을 보여준다.</li>
        <li>세로 : res/layout/*.xml<br>가로 : res/layout-land/*.xml</li>
      </ul>
      <pre>
package com.xxx.sampleorientation

import android.os.Bundle
import android.os.PersistableBundle
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import com.jeongchaeuk.sampleorientation.databinding.ActivityMainBinding

class MainActivity : AppCompatActivity() {
    private lateinit var binding: ActivityMainBinding
    private var name: String? = null

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        binding = ActivityMainBinding.inflate(layoutInflater)
        setContentView(binding.root)

        showToast("onCreate()")

        binding.button.setOnClickListener {
            name = binding.editText.text.toString()
            showToast("입력된 값을 변수에 저장했습니다. ${name}")
        }

        if (savedInstanceState !== null) {
            name = savedInstanceState.getString("name")
            showToast("값을 복원 했습니다. ${name}")
        }
    }

    override fun onSaveInstanceState(outState: Bundle, outPersistentState: PersistableBundle) {
        super.onSaveInstanceState(outState, outPersistentState)

        outState.putString("name", name)
    }

    override fun onStart() {
        super.onStart()
        showToast("onStart()")
    }

    override fun onStop() {
        super.onStop()
        showToast("onStop()")
    }

    override fun onDestroy() {
        super.onDestroy()
        showToast("onDestroy()")
    }

    private fun showToast(msg: String) {
        Toast.makeText(this, msg, Toast.LENGTH_SHORT).show()
    }
}</pre>
      <h4>Activity를 유지할 수 있는 방법</h4>
      configChanges 속성 값이 설정되면 system은 activity의 상태 변화를 activity 쪽으로 알려주기만 한다.<br>
      따라서 개발자가 직접 각 상태 변화에 따른 대응 코드를 작성해야 한다.<br>
      참고: <a href="https://developer.android.com/guide/topics/resources/runtime-changes" target="_blank">Handle configuration changes</a><br><br>
      AndroidManifest.xml
      <pre>
&lt;?xml version="1.0" encoding="utf-8"?>
&lt;manifest
  xmlns:android="http://schemas.android.com/apk/res/android"
  package="com.xxx.sampleorientation2">

  &lt;application
    ...
    &lt;activity
      android:name=".MainActivity"
      android:configChanges="orientation|screenSize|keyboardHidden">
      ...      
    &lt;/activity>
  &lt;/application>

&lt;/manifest></pre><br>

      MainActivity.kt
      <pre>
package com.xxx.sampleorientation2

import android.content.res.Configuration
import android.os.Bundle
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity

class MainActivity : AppCompatActivity() {
  ...
    override fun onConfigurationChanged(newConfig: Configuration) {
        super.onConfigurationChanged(newConfig)

        when (newConfig.orientation) {
            Configuration.ORIENTATION_PORTRAIT->{ showToast("ORIENTATION_PORTRAIT") }
            Configuration.ORIENTATION_LANDSCAPE->{ showToast("ORIENTATION_LANDSCAPE") }
            else->{ showToast("ORIENTATION_UNKNOWN") }
        }
    }

    private fun showToast(text: String) {
        Toast.makeText(this, text, Toast.LENGTH_SHORT).show()
    }
}</pre><br>
      방향을 고정하고 싶다면 screenOrientation 속성을 사용한다.
      <pre>
&lt;activity
  android:name=".MainActivity"
  android:screenOrientation="landscape"
  android:configChanges="orientation|screenSize|keyboardHidden">
&lt;/activity>
</pre>
      <h2>03-4 Toast, SnackBar 그리고 대화상자 사용하기</h2>
      <ul>
        <li>AndroidStudio에서 debug message 출력을 위해 Log class를 사용한다.</li>
        <li>Logcat window에 message가 출력된다.</li>
      </ul>
      Toast 출력<br>
      <ul>
        <li>open static fun makeText(context: Context!, text: CharSequence!, duration: Int): Toast!</li>
        <li>open fun show(): Unit</li>
      </ul>
      <ul>
        <li>open fun setGravity(gravity: Int, xOffset: Int, yOffset: Int): Unit<br>
          Toast view가 보이는 위치를 변경한다.
        </li>
        <li>open fun setMargin(horizontalMargin: Float, verticalMargin: Float): Unit<br>
          Toast view의 외부 여백을 지정한다.
        </li>
      </ul>
      <h4>Toast 위치 바꿔 보여주기</h4>
      <pre>
package com.xxx.sample

import android.os.Bundle
import android.view.Gravity
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import com.xxx.sample.databinding.ActivityMainBinding

class MainActivity : AppCompatActivity() {
    private lateinit var binding: ActivityMainBinding

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        binding = ActivityMainBinding.inflate(layoutInflater)
        setContentView(binding.root)

        binding.button.setOnClickListener {
            var toast = Toast.makeText(applicationContext, "toast", Toast.LENGTH_SHORT)

            val x = try {
                binding.editText.text.toString().toInt()
            } catch (e: NumberFormatException) {
                0
            }

            val y = try {
                binding.editText2.text.toString().toInt()
            } catch (e: NumberFormatException) {
                0
            }

            toast.setGravity(Gravity.TOP, x, y)
            toast.show()
        }
    }
}</pre>
      <h4>Toast 모양 바꿔 보여주기</h4>
      Toast의 모양<br>/res/drawable/toast.xml
      <pre>
&lt;?xml version="1.0" encoding="utf-8"?>
&lt;shape
  xmlns:android="http://schemas.android.com/apk/res/android"
  android:shape="rectangle">
  &lt;stroke
    android:width="4dp"
    android:color="#AA0" />
  &lt;solid android:color="#830" />
  &lt;padding
    android:bottom="20dp"
    android:left="20dp"
    android:right="20dp"
    android:top="20dp" />
  &lt;corners android:radius="15dp"/>
&lt;/shape></pre><br>
      Toast 위한 layout<br>/res/layout/toastborder.xml
      <pre>
&lt;?xml version="1.0" encoding="utf-8"?>
&lt;LinearLayout
  xmlns:android="http://schemas.android.com/apk/res/android"
  android:id="@+id/toast_layout_root"
  android:layout_width="match_parent"
  android:layout_height="match_parent"
  android:orientation="horizontal"
  android:padding="10dp">

  &lt;TextView
    android:id="@+id/textView"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:background="@drawable/toast"
    android:padding="20dp"
    android:textSize="32sp" />
&lt;/LinearLayout></pre><br>
      MainActivity.kt
      <pre>
package com.xxx.sample

import android.os.Bundle
import android.view.Gravity
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import com.xxx.sample.databinding.ActivityMainBinding
import com.xxx.sample.databinding.ToastborderBinding

class MainActivity : AppCompatActivity() {
    ...
    private lateinit var toastBinding: ToastborderBinding

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        ...
        binding.button2.setOnClickListener {
            toastBinding = ToastborderBinding.inflate(layoutInflater)
            toastBinding.textView.text = "모양 바꾼 Toast"

            var toast = Toast(this)
            toast.setGravity(Gravity.CENTER, 0, -100)
            toast.duration = Toast.LENGTH_SHORT
            
            // API Level 30 부터 지원하지 않는다!
            toast.view = toastBinding.root

            toast.show()
        }
    }
}</pre>
      <h4>Snackbar 보여주기</h4>
      <ul>
        <li>Material library를 project에 추가해야 사용할 수 있다.</li>
        <li>AppBarLayout를 download 함으로 추가할 수 있다.</li>
      </ul>
      <pre>
binding.button3.setOnClickListener {
  // it: View!
  Snackbar.make(it, "스낵바입니다.", Snackbar.LENGTH_LONG).show()
}</pre>
      <h4>알림 대화상자 보여주기</h4>
      <pre>
import android.content.DialogInterface
import androidx.appcompat.app.AlertDialog
...        
binding.button.setOnClickListener {
  AlertDialog.Builder(this)
    .setTitle("안내")
    .setMessage("종료하시겠습니까?")
    .setIcon(android.R.drawable.ic_dialog_alert)
    .setPositiveButton("예") { dialog, which ->
        run {
            binding.textView.text = "예 버튼이 눌렸습니다."
        }
    }
    .setNeutralButton("취소") { dialog, which ->
        run {
            binding.textView.text = "취소 버튼이 눌렸습니다."
        }
    }
    .setNegativeButton("아니오") { dialog, which ->
        run {
            binding.textView.text = "아니오 버튼이 눌렀습니다."
        }
    }
    .create()
    .show()
}</pre>
      <img src="alert_dialog.png" width="372px" height="165px" style="box-shadow: 1px 1px 3px black;" />
      <h2>03-5 ProgressBar 사용하기</h2>
      <h4>ProgressBar</h4>
      작업의 진행 정도를 표시하거나 작업이 진행 중임을 사용자에게 알려준다.<br>
      <table>
        <caption></caption>
        <tr>
          <th>속성</th>
          <th>설명</th>
        </tr>
        <tr>
          <td>막대 모양</td>
          <td>작업의 진행 정도를 알려 준다.<br>style 속성 값을 '?android:attr/progressBarStyleHorizontal'로 설정한다.</td>
        </tr>
        <tr>
          <td>원 모양</td>
          <td>작업이 진행 중임을 알려준다.</td>
        </tr>
      </table><br>
      <table>
        <tr>
          <th>method</th>
          <th>설명</th>
        </tr>
        <tr>
          <td>open fun setProgress(progress: Int): Unit</td>
          <td>현재 값을 설정한다.</td>
        </tr>
        <tr>
          <td>fun incrementProgressBy(diff: Int): Unit</td>
          <td>현재 값을 기준으로 값을 더하거나 뺀다.</td>
        </tr>
      </table>
      <h1 class="chapter-title"><span class="chapter-number">04</span>여러 화면 간 전환하기</h1>
      <h2>04-1 Layout Inflation 이해하기</h2>
      <ul>
        <li>App을 실행할 때 layout file(*.xml)과 source code file(*.kt / *.java)이 필요하다.<br>
        <li><span class="my-strong">setContentView(R.layout.{layout file name})</span> method는 화면 전체에 표시할 XML layout이나 view 객체를 지정한다.
          <ul>
            <li>R.layout : "/res/layout" folder</li>
            <li>layout file name에 확장자 xml은 포함하지 않는다.</li>
            <li>ex) R.layout.activity_main</li>
          </ul>
        </li>
        <li>App이 실행될 때 XML layout 내용이 memory에 객체화되고 이것을 source file에서 사용한다.</li>
        <li>XML layout 내용이 memory에 객체화되는 과정을 <span class="my-strong">Inflation</span>이라고 한다.</li>
        <li>Inflation 되기 전에는 layout element들을 이용할 수 없다.</li>
      </ul>
      <h4>부분화면 보여주기</h4>
      <ul>
        <li>부분 화면(부분 layout)을 memory에 객체화하려면 <b>Inflater</b>를 사용한다.</li>
        <li>Android는 이를 위해 system service로 <span class="my-strong">LayoutInflater</span> class를 제공한다.<br>
          (system service는 단말기가 시작되면서 항상 실행되는 service이다.)<br>
          LayoutInflater는 layout XML file로 대응되는 <b>'android.view.View'</b> 객체를 만든다.</li>
        <li>이 class 객체는 직접 생성하지 않고 아래 method들로 이미 현재 컨텍스트에 연결되고 실행중인 기기에 대해 올바르게 구성된 표준 LayoutInflater instance를 검색한다.<br>
          <table>
            <tr>
              <th>class</th>
              <th>method</th>
              <th>parameter</th>
            </tr>
            <tr>
              <td>android.app.Activity</td>
              <td>open fun getLayoutInflater(): LayoutInflater</td>
              <td></td>
            </tr>
            <tr>
              <td>android.content.Context</td>
              <td>abstract fun getSystemService(name: String): Any!</td>
              <td>Context.LAYOUT_INFLATER_SERVICE</td>
            </tr>
            <tr>
              <td>android.view.LayoutInflater</td>
              <td>open static fun from(context: Context!): LayoutInflater!</td>
              <td>this</td>
            </tr>
          </table>
        </li>
      </ul>
      activity_menu.xml<br>
      <pre>
&lt;?xml version="1.0" encoding="utf-8"?>
&lt;LinearLayout
  xmlns:android="http://schemas.android.com/apk/res/android"
  xmlns:app="http://schemas.android.com/apk/res-auto"
  xmlns:tools="http://schemas.android.com/tools"
  android:layout_width="match_parent"
  android:layout_height="match_parent"
  android:orientation="vertical"
  tools:context=".MenuActivity">

  &lt;TextView
    android:id="@+id/textView"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:text="버튼을 눌러 부분 화면을 추가하세요."/>

  &lt;Button
    android:id="@+id/button"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:text="추가하기"/>

  &lt;LinearLayout
    android:id="@+id/container"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">
  &lt;/LinearLayout>
&lt;/LinearLayout></pre><br>
      sub1.xml<br>
      <pre>
&lt;?xml version="1.0" encoding="utf-8"?>
&lt;LinearLayout
  xmlns:android="http://schemas.android.com/apk/res/android"
  android:layout_width="match_parent"
  android:layout_height="match_parent"
  android:orientation="vertical">

  &lt;TextView
    android:id="@+id/textView"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:text="부분화면 1"/>

    &lt;CheckBox
      android:id="@+id/checkBox"
      android:layout_width="wrap_content"
      android:layout_height="wrap_content"
      android:text="동의합니다."/>
&lt;/LinearLayout>  
</pre><br>
      MenuActivity.kt<br>
      <pre>
package com.xxx.sample

import android.os.Bundle
import androidx.appcompat.app.AppCompatActivity
import com.xxx.sample.databinding.ActivityMenuBinding
import com.xxx.sample.databinding.Sub1Binding

class MenuActivity : AppCompatActivity() {
  private lateinit var binding: ActivityMenuBinding
  private lateinit var subBinding: Sub1Binding

  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)

    binding = ActivityMenuBinding.inflate(layoutInflater)
    setContentView(binding.root)

    binding.button.setOnClickListener {
        subBinding = Sub1Binding.inflate(layoutInflater, binding.container, true)
        subBinding.checkBox.text = "로딩되었습니다."
    }
  }
}</pre><br>
      AndroidManifest.xml<br>
      <pre>
&lt;?xml version="1.0" encoding="utf-8"?>
&lt;manifest
  xmlns:android="http://schemas.android.com/apk/res/android"
  package="com.xxx.sample">

  &lt;application
    android:allowBackup="true"
    android:icon="@mipmap/ic_launcher"
    android:label="@string/app_name"
    android:roundIcon="@mipmap/ic_launcher_round"
    android:supportsRtl="true"
    android:theme="@style/Theme.Samples">

    &lt;activity android:name=".MenuActivity">
      &lt;intent-filter>
        &lt;action android:name="android.intent.action.MAIN" />
        &lt;category android:name="android.intent.category.LAUNCHER" />
      &lt;/intent-filter>
    &lt;/activity>

    &lt;activity android:name=".MainActivity">&lt;/activity>

  &lt;/application>
&lt;/manifest></pre>
      <h2>04-2 여러 화면 만들고 화면 간 전환하기</h2>
      <h4>Android App을 구성하는 4가지 요소</h4>
      <ul>
        <li>Activity</li>
        <li>Service</li>
        <li>Broadcast Receiver</li>
        <li>Content Provider</li>
      </ul>
      App을 만들어 단말기에 설치했을 때 Android system이 이 요소들에 대한 정보를 요구한다.<br>
      이 정보는 <span class="my-strong">AndroidManifest.xml</span>에 담겨 있다.<br><br>
      <ul>
        <li>화면은 Activity로 구현한다.</li>
        <li>
          <table>
            <caption>새 activity를 표시하는 방법</caption>
            <tr>
              <th>method</th>
              <th>설명</th>
            </tr>
            <tr>
              <td>
                <pre class="no-bg">
open fun startActivity(intent: Intent!): Unit</pre>
              </td>
              <td>새 Activity를 화면에 표시한다.</td>
            </tr>
            <tr>
              <td>
                <pre class="no-bg">
open fun startActivityForResult(
    intent: Intent!,
    requestCode: Int
): Unit</pre>
              </td>
              <td>새 Activity를 화면에 표시하고 그 응답을 받아 처리한다.<br>
                requestCode는 일반적으로 각각의 Activity를 구별하기 위해 사용된다.
              </td>
            </tr>
          </table>
          MainActivity.kt
          <pre>
package com.xxx.sample

import android.content.Intent
import android.os.Bundle
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import com.xxx.sample.databinding.ActivityMainBinding

class MainActivity : AppCompatActivity() {
  private lateinit var binding: ActivityMainBinding

  companion object {
      const val REQUEST_CODE_MENU = 101
  }

  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)

    binding = ActivityMainBinding.inflate(layoutInflater)
    setContentView(binding.root)

    binding.button.setOnClickListener {
        val intent = Intent(applicationContext, MenuActivity::class.java)
        startActivityForResult(intent, REQUEST_CODE_MENU)
    }
  }
}</pre>
        </li>
        <li>
          <table>
            <caption>응답 결과를 보내는 방법</caption>
            <tr>
              <th>method</th>
              <th>설명</th>
            </tr>
            <tr>
              <td>
                <pre class="no-bg">
fun setResult(
  resultCode: Int, 
  data: Intent!
): Unit</pre>
              </td>
              <td>새 Activity에서 이전 Activity -호출자(caller)-로 intent를 사용해 extra data를 전달한다.</td>
            </tr>
          </table>
          MenuActivity.kt
          <pre>
package com.xxx.sample

import android.content.Intent
import android.os.Bundle
import androidx.appcompat.app.AppCompatActivity
import com.xxx.sample.databinding.ActivityMenuBinding

class MenuActivity : AppCompatActivity() {
  private lateinit var binding: ActivityMenuBinding

  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)

    binding = ActivityMenuBinding.inflate(layoutInflater)
    setContentView(binding.root)

    binding.button.setOnClickListener {
      // 'name' 이름의 extra data를 만든다.
      val intent = Intent().putExtra("name", "peter")
      // 응답을 보낸다.
      setResult(RESULT_OK, intent)
      // 현재 activity를 닫는다.
      finish()
    }
  }
}
</pre>
        </li>
        <li>
          <table>
            <caption>응답을 받아 처리하는 방법</caption>
            <tr>
              <th>method</th>
              <th>설명</th>
            </tr>
            <tr>
              <td>
                <pre class="no-bg">
protected open fun onActivityResult(
  // startActivityForResult()에 전달한 값.
  // 응답한 Activity를 구별하기위해 사용된다.
  requestCode: Int,
  
  // 전달 받은 응답 코드 값.
  resultCode: Int,
  
  // 전달 받은 extra data.
  data: Intent!
): Unit</pre>
              </td>
              <td>새로 연 Activity가 종료되었을 때 호출된다.</td>
            </tr>
          </table><br>
          MainActivity.kt
          <pre>
  ...
class MainActivity : AppCompatActivity() {
  ...
  override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
    super.onActivityResult(requestCode, resultCode, data)

    val request = when (requestCode) {
      REQUEST_CODE_MENU -> {
        val result = when (resultCode) {
          RESULT_OK -> {
            val value = data?.getStringExtra("name") ?: "no data"
            "응답으로 전달된 name=${value}"
          }
          else -> {
            "Unknown result code"
          }
        }

        Toast.makeText(this, result, Toast.LENGTH_LONG).show()

        "requestCode=${requestCode}, resultCode=${resultCode}"
      }
      else -> {
        "Unknown request code"
      }
    }

    Toast.makeText(this, request, Toast.LENGTH_LONG).show()
  }
  ...
}</pre>
        </li>
      </ul>
      <h4>정리</h4>
      <table>
        <tr>
          <th>과정</th>
          <th>설명</th>
        </tr>
        <tr>
          <td>새 Activity 만들기</td>
          <td>새 Activity를 추가하면 XML layout file 하나와 source file 하나가 만들어진다.<br>Manifest file에 Activity tag가 추가된다.</td>
        </tr>
        <tr>
          <td>새 Activity의 XML layout 정의하기</td>
          <td>새로 만들어진 XML layout을 수정하여 새 Activity의 화면이 어떻게 배치될지를 작성한다.</td>
        </tr>
        <tr>
          <td>Main Activity에서 새 Activity 호출하기</td>
          <td><span class="my-strong">startActivityForResult()</span>로 새 Activity를 호출한다.</td>
        </tr>
        <tr>
          <td>새 Activity에서 응답 보내기</td>
          <td><span class="my-strong">setResult()</span>로 응답을 보낸다.</td>
        </tr>
        <tr>
          <td>응답 처리하기</td>
          <td><span class="my-strong">onActivityResult()</span>를 재정의하여 새 Activity에서 보낸 응답을 처리한다.</td>
        </tr>
      </table>
      <h2>04-3 Intent 살펴보기</h2>
      <h4>Intent의 역할과 사용 방식</h4>
      <ul>
        <li>android.content.Intent는 App 구성 요소간에 작업 수행을 위한 정보를 전달하는 역할을 한다.</li>
        <li>Intent를 전달할 수 있는 대표적인 method
          <ul>
            <li>startActivity(), startActivityForResult()</li>
            <li>startService(), bindService()</li>
            <li>broadcastIntent()</li>
          </ul>
        </li>
        <li>Intent의 기본 구성 요소
          <ul>
            <li>Action : 수행할 기능</li>
            <li>Data : action이 수행될 대상의 data</li>
            <li>
              <table>
                <cation>예시</cation>
                <tr>
                  <th>Action</th>
                  <th>Data</th>
                  <th>설명</th>
                </tr>
                <tr>
                  <td>ACTION_DIAL</td>
                  <td>tel:010-1234-1234</td>
                  <td>주어진 전화번호를 이용해 전화걸기 화면을 보여준다.</td>
                </tr>
                <tr>
                  <td>ACTION_VIEW</td>
                  <td>tel:010-1234-1234</td>
                  <td>주어진 전화번호를 이용해 전화걸기 화면을 보여준다.<br>URI 값의 유형에 따라 VIEW action이 다른 기능을 수행한다.</td>
                </tr>
                <tr>
                  <td>ACTION_EDIT</td>
                  <td>content://contacts/people/2</td>
                  <td>전화번호부 database에 있는 정보 중에서 id 값이 2인 정보를 편집하기 위한 화면을 보여준다.</td>
                </tr>
                <tr>
                  <td>ACTION_VIEW</td>
                  <td>content://contacts/people</td>
                  <td>전화번호부 database의 내용을 보여준다.</td>
                </tr>
              </table>
            </li>
            <li>Data는 그 형식이 (MIME type) 어떤 것인가를 system이 확인한 후 적절한 Activity를 자동으로 찾아 보여주기도 한다.</li>
          </ul>
        </li>
        <li>android.content.Intent 생성자
          <table>
            <tr>
              <th>생성자</th>
              <th>설명</th>
            </tr>
            <tr>
              <td>
                <pre class="no-bg">Intent()</pre>
              </td>
              <td>빈 객체를 만든다.</td>
            </tr>
            <tr>
              <td>
                <pre class="no-bg">Intent(o: Intent!)</pre>
              </td>
              <td>복사 생성자</td>
            </tr>
            <tr>
              <td>
                <pre class="no-bg">Intent(action: String!)</pre>
              </td>
              <td>주어진 action으로 객체를 만든다. 다른 fields(data, type, class)는 null 이다.</td>
            </tr>
            <tr>
              <td>
                <pre class="no-bg">Intent(action: String!, uri: Uri!)</pre>
              </td>
              <td>주어진 action과 주어진 data uri로 객체를 만든다.</td>
            </tr>
            <tr>
              <td>
                <pre class="no-bg">
Intent(
  packageContext: Context!, 
  cls: Class&lt;*>!)</pre>
              </td>
              <td>component를 위한 intent를 만든다. 다른 field(action, data, type, class)는 null이고 나중에 변경될 수 있다.<br>
                cls는 intent를 위해 사용될 component class 이름이다.
              </td>
            </tr>
            <tr>
              <td>
                <pre class="no-bg">
Intent(
  action: String!, 
  uri: Uri!, 
  packageContext: Context!, 
  cls: Class&lt;*>!)</pre>
              </td>
              <td>action과 data로 component를 위한 intent를 만든다.</td>
            </tr>
          </table>
        </li>
        <li>종류
          <ul>
            <li>명시적(Explicit) Intent : Intent에 class 객체나 component 이름을 지정하여 호출할 대상을 확실히 알 수 있는 경우.</li>
            <li>암시적(Implicit) Intent : action, data를 지정하긴 했지만 호출할 대상이 달라질 수 있는 경우.
              <ul>
                <li>MIME 형식에 따라 system에서 적절한 다른 app의 activity를 찾은 후 표시하는 방식을 사용한다.</li>
                <li>
                  <table>
                    <tr>
                      <th>속성</th>
                      <th>설명</th>
                    </tr>
                    <tr>
                      <td>Category</td>
                      <td>action이 실행되는 데 필요한 추가적인 정보를 제공한다.<br>예) CATEGORY_LAUNCHER : <br>
                        최상위 app으로 설치된 app들의 목록을 보여주는 application launcher 화면에 이 app을 보여주어야 한다는 것을 의미한다.</td>
                    </tr>
                    <tr>
                      <td>Type</td>
                      <td>data의 MIME 형식을 명시적으로 지정한다.</td>
                    </tr>
                    <tr>
                      <td>Component</td>
                      <td>intent에 사용될 component class 이름을 명시적으로 지정한다.</td>
                    </tr>
                    <tr>
                      <td>Extra data</td>
                      <td>intent는 추가적인 정보를 넣을 수 있도록 Bundle 객체를 담고 있다.<br>
                        이 객체를 통해 intent 안에 더 많은 정보를 넣어 다른 app 구성 요소에 전달할 수 있다.</td>
                    </tr>
                  </table>
                  <pre>
// 암시적
binding.button.setOnClickListener {
  val data = binding.editText.text.toString() // "tel:010-1000-1000"
  val intent = Intent(Intent.ACTION_VIEW, Uri.parse(data))
  startActivity(intent)
}</pre>
                  <pre>
// 명시적
binding.button2.setOnClickListener {
  // 방법 1.
  startActivityForResult(Intent(applicationContext, MenuActivity::class.java), REQUEST_CODE_MENU)

  // 방법 2.
  val intent = Intent()
  intent.component = ComponentName("com.xxx.sample", "com.xxx.sample.MenuActivity")
  startActivityForResult(intent, REQUEST_CODE_MENU)
}</pre>
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
      <h2>04-4 Flag와 Extra Data 사용하기</h2>
      Activity에 intent를 중복해서 만들면 같은 activity가 중복해서 만들어진다.<br>이런 문제는 Flag를 사용해 조정할 수 있다.
      <h4>Flag</h4>
      <ul>
        <li>Activity는 ActivityManager라는 객체에 의해 Activity Stack이라는 것으로 관리된다.</li>
        <li>이 stack는 activity를 차곡차곡 쌓아두었다가 가장 상위에 있던 activity가 없어지면 이전의 activity가 다시 화면에 보이게 된다.</li>
        <li>즉, 동일한 activity를 여러번 실행하면 같은 activity가 여러개 stack에 들어가게 되고 동시에 data를 여러 번 접근하거나 resource를 여러 번 사용하는 문제가 발생할 수 있다.</li>
        <li>대표적인 Flag
          <table>
            <tr>
              <th>flag</th>
              <th>설명</th>
            </tr>
            <tr>
              <td>FLAG_ACTIVITY_SINGLE_TOP</td>
              <td>activity를 만들 때 이미 만들어진게 있으면 그것을 사용한다.<br>
                <ul>
                  <figcaption>받은 Intent 객체를 참조하는 방법</figcaption>
                  <li>새 activity가 만들어진 경우<br><span class="my-strong">onCreate()</span> 안에서 <span class="my-strong">getIntent()</span>로 참조할 수 있다.</li>
                  <li>기존 activity를 사용하는 경우<br><span class="my-strong">onNewIntent()</span>를 재정의해서 참조할 수 있다.<br>
                    <pre class="no-bg">protected open fun onNewIntent(intent: Intent!): Unit</pre>
                    activity가 이미 memory에 객체로 만들어져 있다면 activity를 다시 표시하더라도 onCreate()가 호출되지 않는다.
                  </li>
                </ul>
              </td>
            </tr>
            <tr>
              <td>FLAG_ACTIVITY_NO_HISTORY</td>
              <td>activity가 stack에 추가되지 않는다. 일회성 activity에 사용된다.</td>
            </tr>
            <tr>
              <td>FLAG_ACTIVITY_CLEAR_TOP</td>
              <td>이 activity 위에 있는 모든 activity를 종료 시킨다.</td>
            </tr>
          </table>
        </li>
      </ul>
      <h4>부가(Extra) Data</h4>
      <ul>
        <li>Intent 안에는 Bundle 객체가 들어 있는데, putExtra(), get{data type}Extra()로 extra data를 넣거나 빼낼 수 있다.</li>
        <li>기본 자료형, byte 배열, Serializable 객체를 다룰 수 있다.</li>
        <li>extra data를 (key, value) 쌍으로 처리한다.</li>
        <li>get{data type}Extra()는 data 값이 없으면 defaultValue 값이 반환된다.</li>
        <li>객체 data는 byte 배열로 변환하거나 Serializable interface를 구현한 객체를 만들어 직렬화한 다음 전달해야 한다.</li>
        <li>Android는 Serializable interface와 유사한 <span class="my-strong">Parcelable</span> interface를 권장한다.
          <table>
            <tr>
              <th>구현해야 할 것들</th>
              <th>설명</th>
            </tr>
            <tr>
              <td>
                <pre class="no-bg">abstract fun describeContents(): Int</td>
              <td>직렬화하려는 객체의 유형을 구분할 때 사용한다.</td>
            </tr>
            <tr>
              <td><pre class="no-bg">
abstract fun writeToParcel(
  dest: Parcel!,
  flags: Int
): Unit</pre>
              </td>
              <td>객체가 가지고 있는 data를 Parcel 객체로 만들어 준다.</td>
            </tr>
            <tr>
              <td>CREATOR 상수</td>
              <td>Parcel 객체로부터 data를 읽어서 객체를 생성하는 역할을 한다.</td>
            </tr>
          </table>
      </ul>
      </li>
      </ul>
      build.gradle(Module)
      <pre>
plugins {
  ...
  // @Parcelize를 사용하기 위한 plug-in 추가.
  <span class="my-strong">id 'kotlin-parcelize'</span> 
}</pre><br>
      SimpleData.kt
      <pre>
package com.xxx.sampleparcelable

import android.os.Parcelable
import kotlinx.parcelize.Parcelize

// @Parcelize는 Kotlin compiler에게 writeToParcel(), describeContents(), CREATOR를 자동으로 만들게 한다.
<span class="my-strong">@Parcelize</span>
class SimpleData(var number: Int, var message: String): Parcelable</pre><br>
      MainActivity.kt
      <pre>
package com.xxx.sampleparcelable

import android.content.Intent
import android.os.Bundle
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import com.xxx.sampleparcelable.databinding.ActivityMainBinding

class MainActivity : AppCompatActivity() {
  private lateinit var binding: ActivityMainBinding

  companion object {
    const val REQUEST_CODE = 100
    const val KEY_SIMPLE_DATA = "data"
  }

  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)

    binding = ActivityMainBinding.inflate(layoutInflater)
    setContentView(binding.root)

    binding.button.setOnClickListener {
      val intent = Intent(applicationContext, MenuActivity::class.java)
      intent.putExtra(KEY_SIMPLE_DATA, SimpleData(100, "Hello Android!"))
      startActivityForResult(intent, REQUEST_CODE)
    }
  }

  override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
    super.onActivityResult(requestCode, resultCode, data)

    val result = data?.getStringExtra("name") ?: "no data"

    Toast.makeText(applicationContext, "$requestCode, $resultCode, $result", Toast.LENGTH_SHORT).show()
  }
}</pre><br>
      /res/layout/activity_main.xml
      <pre>
&lt;?xml version="1.0" encoding="utf-8"?>
&lt;LinearLayout
  xmlns:android="http://schemas.android.com/apk/res/android"
  xmlns:app="http://schemas.android.com/apk/res-auto"
  xmlns:tools="http://schemas.android.com/tools"
  android:layout_width="match_parent"
  android:layout_height="match_parent"
  android:gravity="center"
  android:orientation="vertical"
  android:padding="5dp"
  tools:context=".MainActivity">

  &lt;Button
    android:id="@+id/button"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="메뉴 화면 표시하기"
    android:textSize="24sp" />
&lt;/LinearLayout>
</pre><br>
      MenuActivity.kt
      <pre>
package com.xxx.sampleparcelable

import android.content.Intent
import android.os.Bundle
import androidx.appcompat.app.AppCompatActivity
import com.xxx.sampleparcelable.databinding.ActivityMenuBinding

class MenuActivity : AppCompatActivity() {
  private lateinit var binding: ActivityMenuBinding

  companion object {
    const val KEY_SIMPLE_DATA = "data"
  }

  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)

    binding = ActivityMenuBinding.inflate(layoutInflater)
    setContentView(binding.root)

    val data = intent.getParcelableExtra<SimpleData>(KEY_SIMPLE_DATA)
    binding.textView.text = ("전달받은 Data\n" +
      if (data != null)
        "number=${data.number}\nmessage=${data.message}"
      else
        "no data!")

    binding.buttonExit.setOnClickListener {
      val intent = Intent()
      intent.putExtra("name", "peter")
      setResult(RESULT_OK, intent)
      finish()
    }
  }
}</pre><br>
      /res/layout/activity_menu.xml
      <pre>
&lt;?xml version="1.0" encoding="utf-8"?>
&lt;LinearLayout
  xmlns:android="http://schemas.android.com/apk/res/android"
  xmlns:app="http://schemas.android.com/apk/res-auto"
  xmlns:tools="http://schemas.android.com/tools"
  android:layout_width="match_parent"
  android:layout_height="match_parent"
  android:gravity="center"
  android:orientation="vertical"
  android:padding="5dp"
  tools:context=".MenuActivity">

  &lt;TextView
    android:id="@+id/textView"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:gravity="center"
    android:text="전달받은 데이터"
    android:textSize="24sp" />

    &lt;Button
    android:id="@+id/buttonExit"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:layout_marginTop="50dp"
    android:text="돌아가기"
    android:textSize="24sp" />
&lt;/LinearLayout></pre>
      <h2>04-5 Task 관리 이해하기</h2>
      Task를 이용하면 Process처럼 독립적인 실행 단위와 상관없이 어떤 화면들이 같이 동작해야 하는지 흐름을 관리할 수 있다.
      <table class="table-no-border" style="text-align: center;">
        <tr>
          <th class="no-border" colspan="3">Task</th>
        </tr>
        <tr>
          <td style="background-color: aquamarine;">Activity #1</td>
          <td class="no-border">-------------&gt;</td>
          <td style="background-color: bisque;">Activity #2</td>
        </tr>
        <tr>
          <td class="no-border" colspan="3">&nbsp;</td>
        </tr>
        <tr>
          <th class="no-border" colspan="3">Process</th>
        </tr>
        <tr>
          <td style="background-color: aquamarine;">Activity #1</td>
          <td class="no-border" rowspan="4"></td>
          <td style="background-color: bisque;">Activty #2</td>
        </tr>
        <tr>
          <td style="background-color: aquamarine;">VM</td>
          <td style="background-color: bisque;">VM</td>
        </tr>
        <tr>
          <td style="background-color: aquamarine;">Process #1</td>
          <td style="background-color: bisque;">Process #2</td>
        </tr>
        <tr>
          <th>사용자 App</th>
          <th>다른 App</th>
        </tr>
      </table>
      <h4>Process와 Task</h4>
      AndroidManifest.xml에 activity를 등록할 때 Task도 함께 설정할 수 있다.
      <table>
        <tr>
          <th>launchMode</th>
          <th>설명</th>
        </tr>
        <tr>
          <td>standard</td>
          <td>기본값. Task가 새 activity를 stack에 차곡차곡 저장한다.</td>
        </tr>
        <tr>
          <td>singleTop</td>
          <td>FLAG_ACTIVITY_SINGLE_TOP과 같다.<br>
            이미 실행중인 activity가 있다면 그것을 사용한다.</td>
        </tr>
        <tr>
          <td>singleTask</td>
          <td>activity가 실행될 때 새 task를 만든다.</td>
        </tr>
        <tr>
          <td>singleInstance</td>
          <td>activity가 실행될 때 새 task를 만들고, 이후에 만들어지는 activity들은 이 task를 공유하지 않게 한다.</td>
        </tr>
      </table>
      <pre>
&lt;?xml version="1.0" encoding="utf-8"?>
&lt;manifest
  xmlns:android="http://schemas.android.com/apk/res/android"
  package="com.xxx.sampletask">

  &lt;application
    android:allowBackup="true"
    android:icon="@mipmap/ic_launcher"
    android:label="@string/app_name"
    android:roundIcon="@mipmap/ic_launcher_round"
    android:supportsRtl="true"
    android:theme="@style/Theme.SampleTask">
    &lt;activity
      android:name=".MainActivity"
      <span class="my-strong">android:launchMode="singleTop"</span>>
      &lt;intent-filter>
        &lt;action android:name="android.intent.action.MAIN" />
        &lt;category android:name="android.intent.category.LAUNCHER" />
      &lt;/intent-filter>
    &lt;/activity>
  &lt;/application>
&lt;/manifest></pre>
      <h2>04-6 Activity의 수명주기(Life cycle)와 SharedPreferences 이해하기</h2>
      <table>
        <caption>Activity의 대표적인 상태 정보</caption>
        <tr>
          <th>상태</th>
          <th>설명</th>
        </tr>
        <tr>
          <td>실행 (Running)</td>
          <td>화면상에 activity가 보이면서 실행되어 있는 상태.<br>activity stack의 최상위에 있으며 focus를 가지고 있다.</td>
        </tr>
        <tr>
          <td>일시정지 (Paused)</td>
          <td>사용자에게 보이지만 다른 activity가 위에 있어 focus를 받지 못한 상태.<br>대화상자가 위에 있어 일부가 가려진 경우에 해당한다.</td>
        </tr>
        <tr>
          <td>중지 (Stopped)</td>
          <td>다른 activity에 의해 완전히 가려져 보이지 않는 상태.</td>
        </tr>
      </table>
      <ul>
        <li>activity의 상태 정보가 변화하는 것을 activity의 수명주기 또는 생명주기라고 한다.</li>
        <li>상태가 변화하면서 각각에 해당하는 method가 system에 의해 자동으로 호출된다. (Callback Method)</li>
      </ul>
      <img src="activity_lifecycle.png" width="513" height="663" alt="activity_lifecycle.png" />
      <table>
        <caption>Activity의 상태 method</caption>
        <tr>
          <th>method</th>
          <th>설명</th>
        </tr>
        <tr>
          <td>onCreate()</td>
          <td>
            <ul>
              <li>Activity가 처음에 만들어졌을 때 호출된다.</li>
              <li>화면에 보이는 view들의 일반적인 상태를 설정하는 부분.</li>
              <li>이전 상태가 저장되어 있는 경우에는 Bundle 객체를 참조해 이전 상태 복원 가능.</li>
              <li>다음에는 항상 onStart()가 호출된다.</li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>onStart()</td>
          <td>
            <ul>
              <li>Activity가 화면에 보이기 바로 전에 호출된다.</li>
              <li>Activity가 화면 상에 보이면 다음에 onResume()이 호출된다.</li>
              <li>Activity가 화면에서 가려지게 되면 다음에 onStop()이 호출된다.</li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>onResume()</td>
          <td>
            <ul>
              <li>Activity가 사용자와 상호작용하기 바로 전에 호출된다.</li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>onRestart()</td>
          <td>
            <ul>
              <li>Activity가 중지된 이후에 호출되는 method로 다시 시작하기 바로 전에 호출된다.</li>
              <li>다음에는 항상 onStart()가 호출된다.</li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>onPause()</td>
          <td>
            <ul>
              <li>또 다른 Activity를 시작하려고 할 때 호출된다.</li>
              <li>저장되지 않은 data를 저장소에 저장하거나 animation 중인 작업을 중지하는 등의 기능을 수행한다.</li>
              <li>이 method가 return되기 전에는 다음 activity가 시작될 수 없으므로 이 작업은 매우 빨리 수행된 후 return 되어야 한다.</li>
              <li>Activity가 이 상태에 들어가면 system은 activity를 강제로 종료할 수 있다.</li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>onStop()</td>
          <td>
            <ul>
              <li>Activity가 사용자에게 더 이상 보이지 않을 때 호출된다.</li>
              <li>Activity가 소멸되거나 또 다른 activity가 화면을 가릴 때 호출된다.</li>
              <li>Activity가 이 상태에 들어가면 system은 activity를 강제로 종료할 수 있다.</li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>onDestroy()</td>
          <td>
            <ul>
              <li>Activity가 소멸되어 없어지기 전에 호출된다.</li>
              <li>이 method는 activity가 받는 마지막 호출이 된다.</li>
              <li>Activity가 app에 의해 종료되거나(finish() method 호출) system이 강제로 종료시키는 경우에 호출될 수 있다.</li>
              <li>위의 2가지 경우를 구분할 때 isFinishing() method를 이용한다.</li>
              <li>Activity가 이 상태에 들어가면 system은 activity를 강제로 종료할 수 있다.</li>
            </ul>
          </td>
        </tr>
      </table>
      <h4>App 상태 저장 및 복원</h4>
      <table>
        <tr>
          <td>onPause()</td>
          <td rowspan="2">이 두가지 method는 app이 멈추거나 없어질 때,<br>app이 다시 보이거나 새로 실행될 때 호출되므로 이 method를 구현해 app의 상태를 저장하거나 복원한다.</td>
        </tr>
        <tr>
          <td>onResume()</td>
        </tr>
        <tr>
          <td>onSaveInstanceState()</td>
          <td>Activity를 중지시키기 전에 호출된다. 여기서 data를 임시로 저장할 수 있다.</td>
        </tr>
        <tr>
          <td>onCreate()<br>onRestoreInstanceState()</td>
          <td>저장한 data를 읽어온다.</td>
        </tr>
      </table>
      <h4>SharedPreferences</h4>
      <ul>
        <li>App 안에서 간단한 data를 저장하거나 복원할 때 사용한다.</li>
        <li>App 내부에 file을 만든다.</li>
        <li>개발자는 실제로 file을 만들 필요 없이 SharedPreferences의 저장, 복원 method를 이용한다.</li>
      </ul>
      <pre>
package com.xxx.samplelifecycle

import android.app.Activity
import android.content.Intent
import android.os.Bundle
import android.util.Log
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import com.xxx.samplelifecycle.databinding.ActivityMainBinding

class MainActivity : AppCompatActivity() {
  private lateinit var binding: ActivityMainBinding

  companion object {
    const val STORAGE_NAME = "pref"
    const val DATA_KEY = "name"
  }

  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)

    binding = ActivityMainBinding.inflate(layoutInflater)
    setContentView(binding.root)

    binding.button.setOnClickListener {
      startActivity(Intent(applicationContext, MenuActivity::class.java))
    }

    showToast("onCreate")
  }

  private fun showToast(text: String) {
    Toast.makeText(this, text, Toast.LENGTH_SHORT).show()
    Log.d("Main", text)
  }

  override fun onResume() {
    super.onResume()

    loadState()
    showToast("onResume")
  }

  override fun onPause() {
    super.onPause()

    saveState()
    showToast("onPause")
  }

  private fun clearState() {
    getSharedPreferences(STORAGE_NAME, Activity.MODE_PRIVATE)
      .edit()
      .clear()
      .commit()
  }

  private fun saveState() {
    getSharedPreferences(STORAGE_NAME, Activity.MODE_PRIVATE)
      .edit()
      .putString(DATA_KEY, binding.editTextName.text.toString())
      .commit()
  }

  private fun loadState() {
    binding.editTextName.setText(
      try {
        getSharedPreferences(STORAGE_NAME, Activity.MODE_PRIVATE)
          .getString(DATA_KEY, "")
      } catch (e: ClassCastException) {""})
  }

  override fun onSaveInstanceState(outState: Bundle) {
    super.onSaveInstanceState(outState)

    showToast("onSaveInstanceState")
  }

  override fun onRestoreInstanceState(savedInstanceState: Bundle) {
    super.onRestoreInstanceState(savedInstanceState)

    showToast("onRestoreInstanceState")
  }
}</pre>
      <h1 class="chapter-title"><span class="chapter-number">05</span>Fragment 이해하기</h1>
      부분 화면을 위한 layout이나 source code를 한 번만 정의하고 재사용할 수 있도록 만든것이 fragment 다.
      <h2>05-1 Fragment 란?</h2>
      <h4>Fragment 이해하기</h4>
      <ul>사용 목적
        <li>분할된 화면들을 독립적으로 구성하기 위해 사용한다.</li>
        <li>분할된 화면들의 상태를 관리하기 위해 사용한다.</li>
      </ul><br>
      <ul>화면의 의미
        <li>Activity : system에서 관리하는 화면 </li>
        <li>Fragment : 단순히 activity 위에 올라가는 부분 화면</li>
      </ul><br>
      Fragment는 항상 activity에 올라가 있어야 한다.<br>
      Fragment가 동작하는 시점은 memory에 만들어진 시점이 아니라 activity에 올라가는 시점이다.<br><br>
      <table class="table-no-border">
        <caption>Activity가 독립적으로 동작하는 방식을 본떠 만든 Fragment</caption>
        <tr>
          <td>
            <table class="table-no-border" style="text-align: center;">
              <tr>
                <td style="background-color: #faa;">Activity #1</td>
                <td class="no-border" rowspan="4"></td>
                <td style="background-color: #faa;">Activity #2</td>
              </tr>
              <tr>
                <td class="no-border">|</td>
                <td class="no-border">↑</td>
              </tr>
              <tr>
                <td style="background-color: #afa;">Intent</td>
                <td style="background-color: #afa;">Intent</td>
              </tr>
              <tr>
                <td class="no-border">↓</td>
                <td class="no-border">|</td>
              </tr>
              <tr>
                <td style="background-color: #aaf; padding-top: 5px;" colspan="3"><span style="display:inline-block; margin-bottom: 5px; background-color: #faf;border: 1px solid black; padding: 2px 5px">Activity Manager</span><br>Android System</td>
              </tr>
            </table>
          </td>
          <td class="no-border"></td>
          <td style="background-color: #aaf;">
            <table class="table-no-border" style="text-align: center;">
              <tr>
                <td style="background-color: #faa;">Fragment #1</td>
                <td class="no-border" rowspan="4"></td>
                <td style="background-color: #faa;">Fragment #2</td>
              </tr>
              <tr>
                <td class="no-border">|</td>
                <td class="no-border">↑</td>
              </tr>
              <tr>
                <td style="background-color: #afa;">Method 호출</td>
                <td style="background-color: #afa;">Method 호출</td>
              </tr>
              <tr>
                <td class="no-border">↓</td>
                <td class="no-border">|</td>
              </tr>
              <tr>
                <td colspan="3" style="background-color: #faf;">Fragment Manager</td>
              </tr>
              <tr>
                <td class="no-border" colspan="3">Activity</td>
              </tr>
            </table>
          </td>
        </tr>
      </table>
      <h4><a href="https://developer.android.com/guide/fragments/create#setup" target="_blank">환경 설정</a></h4>
      <ul>
        <li>Fragment는 AndroidX Fragment library에 대한 종속성이 필요하다.</li>
        <li>Google Maven repository를 project에 추가해야 한다.</li>
      </ul>
      <table>
        <tr>
          <th>build.gradle(Project)</th>
          <th>build.gradle(Module)</th>
        </tr>
        <tr>
          <td>
            <pre>
buildscript {
  ...
  repositories {
      google()
      ...
  }
}

allprojects {
  repositories {
      google()
      ...
  }
}</pre>
          </td>
          <td>
            <pre>
dependencies {
  def fragment_version = "1.3.3"

  // Java language implementation
  implementation "androidx.fragment:fragment:$fragment_version"
  // Kotlin
  implementation "androidx.fragment:fragment-ktx:$fragment_version"
  ...
}</pre>
          </td>
        </tr>
      </table>
      <h4>Fragment를 화면에 추가하는 방법 이해하기</h4>
      Fragment도 activity 처럼 하나의 XML layout file과 하나의 source code로 구성된다.<br>
      <table>
        <caption><a href="https://developer.android.com/reference/kotlin/androidx/fragment/app/Fragment" target="_blank">Fragment</a>의 주요 method들</caption>
        <tr>
          <th>method</th>
          <th>설명</th>
        </tr>
        <tr>
          <td>
            <pre class="no-bg">
@Nullable
fun getActivity(): FragmentActivity?</pre>
          </td>
          <td>이 fragment를 포함하는 activity를 구한다. Context에 포함된 경우 null을 반환한다.</td>
        </tr>
        <tr>
          <td>
            <pre class="no-bg">
// androidx.fragment.app.Fragment
@NonNull
fun getParentFragmentManager(): FragmentManager</pre>
          </td>
          <td>이 fragment를 포함하는 activity에서 fragment 객체들과 의사소통하는 fragment manager를 구한다.</td>
        </tr>
        <tr>
          <td>
            <pre class="no-bg">
// androidx.fragment.app.FragmentActivity
@NonNull
open fun getSupportFragmentManager(): FragmentManager</pre>
          </td>
          <td>이 fragment를 포함하는 activity에서 fragment 객체들과 의사소통하는 fragment manager를 구한다.</td>
        </tr>
        <tr>
          <td>
            <pre class="no-bg">@Nullable fun getParentFragment(): Fragment?</pre>
          </td>
          <td>부모 fragment를 구한다. 부모가 activity이면 null 이다.</td>
        </tr>
        <tr>
          <td>
            <pre class="no-bg">fun getId(): Int</pre>
          </td>
          <td>이 fragment의 id를 구한다.</td>
        </tr>
        <tr>
          <td>
            <pre class="no-bg">
@MainThread @Nullable open fun onCreateView(
  @NonNull inflater: LayoutInflater, 
  @Nullable container: ViewGroup?, 
  @Nullable savedInstanceState: Bundle?
): View?</pre>
          </td>
          <td>Callback method. 여기서 inflation을 수행한다.</td>
        </tr>
      </table><br>
      <p>XML layout에 <span class="my-strong">&lt;androidx.fragment.app.FragmentContainerView></span> tag를 사용해 추가하거나 FragmentManager의 add() method를 사용해 activity에 추가할 수 있다.</p>
      FragmentManager는 fragment를 activity에 추가(add), 다른 fragment로 바꾸거나(replace) 또는 삭제(remove)할 때 사용할 수 있다.<br>
      <table>
        <caption><a href="https://developer.android.com/reference/kotlin/androidx/fragment/app/FragmentManager" target="_blank">FragmentManager</a>의 주요 method 들</caption>
        <tr>
          <th>method</th>
          <th>설명</th>
        </tr>
        <tr>
          <td>
            <pre class="no-bg">
@NonNull
open fun beginTransaction(): FragmentTransaction</pre>
          </td>
          <td>Fragment를 변경하기 위한 transaction을 시작한다.</td>
        </tr>
        <tr>
          <td>
            <pre class="no-bg">
@Nullable
open fun findFragmentById(
  @IdRes id: Int
): Fragment?</pre>
          </td>
          <td>Id를 이용해 fragment를 찾는다.</td>
        </tr>
        <tr>
          <td>
            <pre class="no-bg">
@Nullable
open fun findFragmentByTag(
  @Nullable tag: String?
): Fragment?</pre>
          </td>
          <td>Tag 정보를 이용해 fragment를 찾는다.</td>
        </tr>
        <tr>
          <td>
            <pre class="no-bg">open fun executePendingTransactions(): Boolean</pre>
          </td>
          <td>Transaction은 commit()을 호출하면 실행되지만 비동기(asynchronous) 방식으로 실행되므로 즉시 실행하고 싶다면 이 method를 추가로 호출해야 한다.</td>
        </tr>
      </table><br>
      <table>
        <caption>Fragment의 특성</caption>
        <tr>
          <th>특성</th>
          <th>설명</th>
        </tr>
        <tr>
          <td>View</td>
          <td>View group에 추가되거나 layout의 일부가 될 수 있다.<br>(View에서 상속받은 것은 아니며 view를 담고 있는 일종의 틀이다.)</td>
        </tr>
        <tr>
          <td>Activity</td>
          <td>수명주기를 가지고 있다.<br>(Context 객체는 아니며 수명주기는 activity에 종속된다.)</td>
        </tr>
      </table>
      <h4>Fragment 만들어 화면에 추가하기</h4>
      <pre>&lt;-- View class 추가 시 tag 추가 방법 예시 -->
&lt;com.xxx.ui.view.MyView
  android:layout_width="match_parent"
  android:layout_height="match_parent" />

&lt;-- Fragment class 추가 시 tag 추가 방법 예시 -->
&lt;fragment
  android:name="com.xxx.ui.fragment.MyFragment"
  android:layout_width="match_parent"
  android:layout_height="match_parent" /></pre><br>
      /res/layout/fragment_main.xml
      <pre>
&lt;?xml version="1.0" encoding="utf-8"?>
&lt;LinearLayout
  xmlns:android="http://schemas.android.com/apk/res/android"
  xmlns:tools="http://schemas.android.com/tools"
  android:layout_width="match_parent"
  android:layout_height="match_parent"
  android:gravity="center"
  android:orientation="vertical"
  tools:context=".MainFragment">

  &lt;TextView
    android:id="@+id/textView"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="메인 프래그먼트"
    android:textSize="30sp" />

  &lt;Button
    android:id="@+id/button"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:layout_marginTop="10dp"
    android:text="메뉴 화면으로"
    android:textSize="24sp" />
&lt;/LinearLayout></pre><br>
      /res/layout/activity_main.xml
      <pre>
&lt;?xml version="1.0" encoding="utf-8"?>
&lt;LinearLayout
  xmlns:android="http://schemas.android.com/apk/res/android"
  xmlns:tools="http://schemas.android.com/tools"
  android:id="@+id/container"
  android:layout_width="match_parent"
  android:layout_height="match_parent"
  android:orientation="vertical"
  tools:context=".MainActivity">

  <span class="my-strong">&lt;fragment</span>
    android:id="@+id/mainFragment"
    <span class="my-strong">android:name="com.xxx.samplefragment.MainFragment"</span>
    android:layout_width="match_parent"
    android:layout_height="match_parent" />
&lt;/LinearLayout></pre><br>
      MainFragment.kt
      <pre>
package com.xxx.samplefragment

import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.Toast
import androidx.fragment.app.Fragment
import com.xxx.samplefragment.databinding.FragmentMainBinding

class MainFragment : <span class="my-strong">Fragment()</span> {
  private lateinit var binding: FragmentMainBinding

  override fun onCreateView(
    inflater: LayoutInflater, 
    container: ViewGroup?,
    savedInstanceState: Bundle?): View? {
      binding = FragmentMainBinding.inflate(inflater, container, false)
      return binding.root
  }

  override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
    super.onViewCreated(view, savedInstanceState)

    binding.button.setOnClickListener {
      Toast.makeText(activity, binding.button.text, Toast.LENGTH_SHORT).show()
    }
  }
}</pre>
      <h4>Button click 했을 때 code에서 fragment 추가하기</h4>
      <table class="table-no-border" style="text-align: center;">
        <caption>Activity와 Fragment가 의사소통하는 방식</caption>
        <tr>
          <td class="no-border" colspan="2"></td>
          <td class="no-border" colspan="3">(2) Transaction 시작<br>beginTransaction()</td>
          <td class="no-border" colspan="2"></td>
        </tr>
        <tr>
          <td style="border: 2px solid #33f">(1) Manager<br>참조하기<br>supportFragmentManager</td>
          <td class="no-border">①<br>→</td>
          <td class="no-border" style="background-color: #aaf;border-radius: 5px;box-shadow: 1px 1px 2px black;"></td>
          <td class="no-border">②<br>→<br><br>④<br>←<br>(3)Transaction 실행<br>commit()</td>
          <td class="no-border" style="background-color: #aaf;border-radius: 5px;box-shadow: 1px 1px 2px black;"></td>
          <td class="no-border">③<br>→<br>추가<br>→<br>삭제<br>→<br>교체<br>→<br>...</td>
          <td class="no-border" style="background-color: #ffa; border: 1px dashed #f00;"><span style="background-color: #33f;color:white; padding:5px">화면 #1</span></td>
        </tr>
        <tr>
          <td class="no-border">Main Activity</td>
          <td class="no-border"></td>
          <td class="no-border">Fragment<br>Manager</td>
          <td class="no-border"></td>
          <td class="no-border">Transaction</td>
          <td class="no-border"></td>
          <td class="no-border">Fragment</td>
        </tr>
      </table>

      /res/layout/fragment_main.xml
      <pre>
&lt;?xml version="1.0" encoding="utf-8"?>
&lt;LinearLayout
  xmlns:android="http://schemas.android.com/apk/res/android"
  xmlns:tools="http://schemas.android.com/tools"
  android:layout_width="match_parent"
  android:layout_height="match_parent"
  android:gravity="center"
  android:orientation="vertical"
  tools:context=".MainFragment">

  &lt;TextView
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="메인 프래그먼트"
    android:textSize="30sp" />

  &lt;Button
    android:id="@+id/button"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:layout_marginTop="10dp"
    android:text="메뉴 화면으로"
    android:textSize="24sp" />
&lt;/LinearLayout></pre><br>
      MainFragment.kt
      <pre>
package com.xxx.samplefragment

import android.os.Bundle
import android.view.View
import androidx.fragment.app.Fragment
import com.xxx.samplefragment.databinding.FragmentMainBinding

class MainFragment : <span class="my-strong">Fragment(R.layout.fragment_main)</span> {

  override fun <span class="my-strong">onViewCreated</span>(view: View, savedInstanceState: Bundle?) {
    super.onViewCreated(view, savedInstanceState)

    <span class="my-strong">FragmentMainBinding.bind(view)</span>.button.setOnClickListener {
      (activity as? MainActivity)?.apply {
        changeFragment(MainActivity.MENU_FRAGMENT)
      }
    }
  }
}</pre><br>
      /res/layout/fragment_menu.xml
      <pre>
&lt;?xml version="1.0" encoding="utf-8"?>
&lt;LinearLayout
  xmlns:android="http://schemas.android.com/apk/res/android"
  xmlns:tools="http://schemas.android.com/tools"
  android:layout_width="match_parent"
  android:layout_height="match_parent"
  android:gravity="center"
  android:orientation="vertical"
  android:background="#fa0"
  tools:context=".MenuFragment">

  &lt;TextView
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="메뉴 프래그먼트"
    android:textSize="30sp" />

  &lt;Button
    android:id="@+id/button"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:layout_marginTop="10dp"
    android:text="메인 화면으로"
    android:textSize="24sp" />
&lt;/LinearLayout></pre><br>
      MenuFragment.kt
      <pre>
package com.xxx.samplefragment

import android.os.Bundle
import android.view.View
import androidx.fragment.app.Fragment
import com.xxx.samplefragment.databinding.FragmentMenuBinding

class MenuFragment : <span class="my-strong">Fragment(R.layout.fragment_menu)</span> {

  override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
    super.onViewCreated(view, savedInstanceState)

    <span class="my-strong">FragmentMenuBinding.bind(view)</span>.button.setOnClickListener {
      (activity as? MainActivity)?.apply {
        changeFragment(MainActivity.MAIN_FRAGMENT)
      }
    }
  }
}</pre><br>
      /res/layout/activity_main.xml
      <pre>
&lt;?xml version="1.0" encoding="utf-8"?>
&lt;LinearLayout
  xmlns:android="http://schemas.android.com/apk/res/android"
  xmlns:tools="http://schemas.android.com/tools"
  android:layout_width="match_parent"
  android:layout_height="match_parent"
  android:orientation="vertical"
  <span class="my-strong">android:id="@+id/container"</span>
  tools:context=".MainActivity">

  &lt;<span class="my-strong">androidx.fragment.app.FragmentContainerView</span>
  <span class="my-strong">android:id="@+id/mainFragment"</span>
  <span class="my-strong">android:name="com.xxx.samplefragment.MainFragment"</span>
    android:layout_width="match_parent"
    android:layout_height="match_parent" />
&lt;/LinearLayout></pre>
      <span class="my-strong">android:name</span> 속성은 만들 fragment의 class 이름이다.<br><br>
      MainActivity.kt
      <pre>
package com.xxx.samplefragment

import android.os.Bundle
import androidx.appcompat.app.AppCompatActivity
import androidx.fragment.app.commit
import androidx.fragment.app.replace
import com.xxx.samplefragment.databinding.ActivityMainBinding

class MainActivity : AppCompatActivity() {
  private lateinit var binding: ActivityMainBinding

  companion object {
    const val MAIN_FRAGMENT = 0
    const val MENU_FRAGMENT = 1
  }

  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)

    binding = ActivityMainBinding.inflate(layoutInflater)
    setContentView(binding.root)
  }

  public fun changeFragment(index: Int) {
    when (index) {
      MAIN_FRAGMENT -> {
        supportFragmentManager<span class="my-strong">.commit</span> {
          
          // R.id.container에 포함된 fragment를 MainFragment로 변경한다. 
          <span class="my-strong">replace&lt;MainFragment>(R.id.container)</span>

          // Animation과 전환이 올바르게 동작하도록
          // transaction에 포함된 fragment들의 상태 변경을 최적화한다.
          setReorderingAllowed(true)

          // Back stack에 transaction을 등록한다.
          // 사용자는 나중에 back button을 눌러 이전 fragment를 다시 가져올 수 있다.
          addToBackStack(null)
        }
      }

      MENU_FRAGMENT -> {
        supportFragmentManager<span class="my-strong">.commit</span> {
          <span class="my-strong">replace&lt;MenuFragment>(R.id.container)</span>
          setReorderingAllowed(true)
          addToBackStack(null)
        }
      }

      else -> {}
    }
  }
}</pre>
      <h4>Fragment의 수명주기</h4>
      <table>
        <caption>화면에 보이기 전에 호출되는 method들</caption>
        <tr>
          <th>method</th>
          <th>설명</th>
        </tr>
        <tr>
          <td>
            <pre class="no-bg">
@MainThread
@CallSuper
open fun onAttach(
  @NonNull context: Context
): Unit</pre>
          </td>
          <td>Fragment가 처음으로 context 연결될 때 호출된다. 이후 onCreate(Bundle)가 호출된다.</td>
        </tr>
        <tr>
          <td>
            <pre class="no-bg">
@MainThread 
@CallSuper 
open fun onCreate(
  @Nullable savedInstanceState: Bundle?
): Unit</pre>
          </td>
          <td>Fragment가 초기화될 때 호출된다.<br>(새 fragment 객체를 만든 시점이 아니다.)</td>
        </tr>
        <tr>
          <td>
            <pre class="no-bg">
@MainThread 
@Nullable
open fun onCreateView(
  @NonNull inflater: LayoutInflater, 
  @Nullable container: ViewGroup?, 
  @Nullable savedInstanceState: Bundle?
): View?</pre>
          </td>
          <td>Fragment와 관련되는 view 계층을 만든다. </td>
        </tr>
        <tr>
          <td>
            <pre class="no-bg">
@MainThread 
open fun onViewCreated(
  @NonNull view: View, 
  @Nullable savedInstanceState: Bundle?
): Unit</pre>
          </td>
          <td>onCreateView() 반환 직후, 저장된 상태가 view에 복원되기 전에 호출된다.<br>이 시점에 아직 fragment의 view 계층은 부모에게 연결되지 않는다.</td>
        </tr>
        <tr>
          <td>
            <pre class="no-bg">
@MainThread
@CallSuper
open fun onStart(): Unit</pre>
          </td>
          <td>Fragment와 연결된 activity가 onStart() 되어 사용자에게 fragment가 보일 때 호출된다.</td>
        </tr>
        <tr>
          <td>
            <pre class="no-bg">
@MainThread
@CallSuper
open fun onResume(): Unit</pre>
          </td>
          <td>Fragment와 연결된 activity가 onResume() 되어 사용자와 상호작용할 수 있을 때 호출된다.</td>
        </tr>
      </table>
      <table><br>
        <caption>중지되면서 호출되는 상태 method들</caption>
        <tr>
          <th>method</th>
          <th>설명</th>
        </tr>
        <tr>
          <td>
            <pre class="no-bg">
@MainThread
@CallSuper
open fun onPause(): Unit</pre>
          </td>
          <td>연결된 activity가 onPause()되어 사용자와 상호작용을 중지할 때 호출된다.</td>
        </tr>
        <tr>
          <td>
            <pre class="no-bg">
@MainThread
@CallSuper
open fun onStop(): Unit</pre>
          </td>
          <td>연결된 activity가 onStop()되어 화면에서 더 이상 보이지 않을 때나 fragment의 기능이 중지되었을 때 호출된다.</td>
        </tr>
        <tr>
          <td>
            <pre class="no-bg">
@MainThread
@CallSuper
open fun onDestroyView(): Unit</pre>
          </td>
          <td>onCreateView()에서 생성된 view가 fragment와 연결이 끊길 때 호출된다.<br>내부적으로 view의 상태가 저장된 후, 부모에게서 제거되기 전에 호출된다.</td>
        </tr>
        <tr>
          <td>
            <pre class="no-bg">
@MainThread
@CallSuper
open fun onDestroy(): Unit</pre>
          </td>
          <td>Fragment가 더이상 사용되지 않을 때 호출된다.</td>
        </tr>
        <tr>
          <td>
            <pre class="no-bg">
@MainThread
@CallSuper
open fun onDetach(): Unit</pre>
          </td>
          <td>Activity와 연결을 끊기 바로 전에 호출된다.</td>
        </tr>
      </table>
      <figure>
        <figcaption style="margin-bottom: .5rem;">Fragment <code>Lifecycle</code> 상태와 fragment 수명주기 callbacks과 fragment의 view <code>Lifecycle</code>의 관계</figcaption>
        <img src="fragment-view-lifecycle.png" width="821px" height="1004px" />
      </figure>
      <figure>
        <figcaption>onStop()과 onSaveInstanceState()의 호출 순서가 다르다.</figcaption>
        <img src="stop-save-order.png" width="966px" helight="318px">
      </figure>
      <table class="table-no-border" style="text-align: center;">
        <caption>Fragment 수명주기</caption>
        <tr>
          <td style="background-color:skyblue">Activity에 fragment 추가</td>
          <td rowspan="6" class="no-border"></td>
          <td style="background-color:skyblue">Activity에서 fragment 제거</td>
        </tr>
        <tr>
          <td class="no-border">↓</td>
          <td class="no-border">↑</td>
        </tr>
        <tr>
          <td>onAttach</td>
          <td>onDetach</td>
        </tr>
        <tr>
          <td class="no-border">↓</td>
          <td class="no-border">↑</td>
        </tr>
        <tr>
          <td>onCreate</td>
          <td>onDestroy</td>
        </tr>
        <tr>
          <td class="no-border">↓</td>
          <td class="no-border">↑</td>
        </tr>
        <tr>
          <td>onCreateView</td>
          <td class="no-border">←<br>Back stack에서<br>복구되는 경우</td>
          <td>onDestroyView</td>
        </tr>
        <tr>
          <td class="no-border">↓</td>
          <td rowspan="7" class="no-border"></td>
          <td rowspan="3" class="no-border">↑</td>
        </tr>
        <tr>
          <td>onViewCreated</td>
        </tr>
        <tr>
          <td class="no-border">↓</td>
        </tr>
        <tr>
          <td>onStart</td>
          <td>onStop</td>
        </tr>
        <tr>
          <td class="no-border">↓</td>
          <td class="no-border">↑</td>
        </tr>
        <tr>
          <td>onResume</td>
          <td>onPause</td>
        </tr>
        <tr>
          <td class="no-border">↓</td>
          <td class="no-border">↑</td>
        </tr>
        <tr>
          <td colspan="3" style="background-color: blueviolet; color:white">Fragment 활성화 (Activity 화면에 보이는 상태)</td>
        </tr>
      </table>
      <h2>05-2 Fragment로 화면 만들기</h2>
      
      <h2>05-3 ActionBar 사용하기</h2>
      <h4>화면에 Menu 기능 넣기</h4>
      <h4>ActionBar 좀 더 살펴보기</h4>
      <h2>05-4 상단 Tab과 하단 Tab 만들기</h2>
      <h4>상단 Tab 보여주기</h4>
      <h4>하단 Tab 보여주기</h4>
      <h2>05-5 ViewPager 만들기</h2>
      <h2>05-6 바로가기 Menu 만들기</h2>
      <h1 class="chapter-title"><span class="chapter-number">06</span>Service와 수신자(Broadcast Receiver) 이해하기</h1>

      <br><br><br>
      <p id="end">- END -</p>
</body>

</html>